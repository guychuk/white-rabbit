import { Complex, Scalar } from '../src/complex';
import { Polynomial } from '../src/polynomial';

// Generated by CodiumAI

describe('Polynomial', () => {

    // Creating a Polynomial from an array of coefficients
    it('should create a Polynomial from an array of coefficients', () => {
        const coefficients: [number, Scalar][] = [[0, 1], [1, 2], [2, 3]];
        const polynomial = Polynomial.fromArray(coefficients);
        expect(polynomial.toString()).toBe('3x^2 + 2x + 1');
    });

    // Creating a Polynomial from a map of coefficients
    it('should create a Polynomial from a map of coefficients', () => {
        const coefficients = new Map([[0, 1], [1, 2], [2, 3]]);
        const polynomial = Polynomial.fromMap(coefficients);
        expect(polynomial.toString()).toBe('3x^2 + 2x + 1');
    });

    // Adding two Polynomials
    it('should add two Polynomials correctly', () => {
        const poly1 = Polynomial.fromArray([[0, new Complex([1, 1])], [1, 2]]);
        const poly2 = Polynomial.fromArray([[0, 3], [1, 4]]);
        const result = poly1.add(poly2);
        expect(result.toString()).toBe('6x + (4 + i)');
    });

    // Subtracting one Polynomial from another
    it('should subtract one Polynomial from another correctly', () => {
        const poly1 = Polynomial.fromArray([[0, 5], [1, 7]]);
        const poly2 = Polynomial.fromArray([[0, 3], [1, 4]]);
        const result = poly1.subtract(poly2);
        expect(result.toString()).toBe('3x + 2');
    });

    // Multiplying two Polynomials
    it('should multiply two Polynomials correctly', () => {
        const poly1 = Polynomial.fromArray([[0, 1], [1, 2]]);
        const poly2 = Polynomial.fromArray([[0, 3], [1, 4]]);
        const result = poly1.multiply(poly2);
        expect(result.toString()).toBe("8x^2 + 10x + 3");
    });

    // Dividing one Polynomial by another
    it('should divide one Polynomial by another correctly', () => {
        const poly1 = Polynomial.fromArray([[2, 1]]);
        const poly2 = Polynomial.fromArray([[1, 1]]);
        const result = poly1.divide(poly2);
        expect(result.toString()).toBe('x');
    });

    // Dividing two Polynomials with different degrees
    it('should divide two Polynomials with different degrees when invoked', () => {
        const poly1 = Polynomial.fromArray([[0, 1], [1, 1], [2, 1]]);
        const poly2 = Polynomial.fromArray([[0, 1], [1, 2]]);
        const result = poly1.divide(poly2, false);
        expect(result.toString()).toBe('0.5x + 0.25');
    });

    // Creating a Polynomial with all zero coefficients
    it('should create a zero Polynomial when all coefficients are zero', () => {
        const coefficients: [number, Scalar][] = [[0, 0], [1, 0], [2, 0]];
        const polynomial = Polynomial.fromArray(coefficients);
        expect(polynomial.isZero()).toBe(true);
        expect(polynomial.toString()).toBe('0');
    });

    // Adding a zero Polynomial to another Polynomial
    it('should return the same Polynomial when adding a zero Polynomial', () => {
        const poly1 = Polynomial.fromArray([[0, 1], [1, 2]]);
        const zeroPoly = Polynomial.fromArray([[0, 0]]);
        const result = poly1.add(zeroPoly);
        expect(result.toString()).toBe('2x + 1');
    });

    // Subtracting a zero Polynomial from another Polynomial
    it('should return the same Polynomial when subtracting a zero Polynomial', () => {
        const poly1 = Polynomial.fromArray([[0, 1], [1, 2]]);
        const zeroPoly = Polynomial.fromArray([[0, 0]]);
        const result = poly1.subtract(zeroPoly);
        expect(result.toString()).toBe('2x + 1');
    });

    // Multiplying a Polynomial by a zero Polynomial
    it('should return a zero Polynomial when multiplying by a zero Polynomial', () => {
        const poly1 = Polynomial.fromArray([[0, 1], [1, 2]]);
        const zeroPoly = Polynomial.fromArray([[0, 0]]);
        const result = poly1.multiply(zeroPoly);
        expect(result.isZero()).toBe(true);
        expect(result.toString()).toBe('0');
    });

    // Dividing a Polynomial by a zero Polynomial (should throw an error)
    it('should throw an error when dividing by a zero Polynomial', () => {
        const poly1 = Polynomial.fromArray([[0, 1], [1, 2]]);
        const zeroPoly = Polynomial.fromArray([[0, 0]]);
        expect(() => poly1.divide(zeroPoly)).toThrow('Division by zero');
    });

    // Substituting zero into a Polynomial
    it('should return the constant term when substituting zero into a Polynomial', () => {
        const poly = Polynomial.fromArray([[0, 5], [1, 7]]);
        const result = poly.substitute(Complex.zero);
        expect(result.equals(new Complex([5, 0]))).toBe(true);
    });

    // Substituting a value into a Polynomial
    it('should substitute a value into a Polynomial when using Cartesian form', () => {
        const coefficients: [number, Scalar][] = [[0, 1], [1, 2], [2, 3]];
        const polynomial = Polynomial.fromArray(coefficients);
        const value = 2;
        const result = polynomial.substitute(value, false);
        expect(result.toString()).toBe('17');
    });

    // Calculating the degree of a Polynomial
    it('should calculate the degree of a Polynomial when having multiple terms', () => {
        const coefficients: [number, Scalar][] = [[0, 1], [1, 2], [2, 3]];
        const polynomial = Polynomial.fromArray(coefficients);
        expect(polynomial.degree()).toBe(2);
    });

    it ("should find the roots of a real polynomial", () => {
        const p = Polynomial.makeLinearMonic(1).multiply(Polynomial.makeLinearMonic(2)).multiply(Polynomial.makeLinearMonic(3));

        const roots = p.findRoots();

        expect(roots.length).toBe(3);

        expect(roots.findIndex(i => i.equals(1))).not.toBe(-1);
        expect(roots.findIndex(i => i.equals(2))).not.toBe(-1);
        expect(roots.findIndex(i => i.equals(3))).not.toBe(-1);
    });

    it ("should find the roots of a complex polynomial", () => {
        const p = Polynomial.makeLinearMonic(1).multiply(Polynomial.makeLinearMonic(new Complex([1, 1]))).multiply(Polynomial.makeLinearMonic(1));

        const roots = p.findRoots();

        expect(roots.length).toBe(3);

        expect(roots.findIndex(i => i.equals(1))).not.toBe(-1);
        expect(roots.findIndex(i => i.equals(new Complex([1, 1])))).not.toBe(-1);
    });
});
